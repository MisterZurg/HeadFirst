package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
)

/*
func main() {
	files, err := ioutil.ReadDir("Chapter_12/my_directory")
	if err != nil {
		log.Fatal(err)
	}
	for _, file := range files {
		if file.IsDir() {
			fmt.Println("Directory:", file.Name())
		} else {
			fmt.Println("File:", file.Name())
		}
	}
}
*/

// Рекурсивная функция, которая получает путь для обработки
func scanDirectory(path string) error {
	fmt.Println(path)                  // Выводит текущий каталог.
	files, err := ioutil.ReadDir(path) // Получает slice с содержимым каталога.
	if err != nil {
		// Вывод отладочной информации для ошибок в вызове ReadDir
		fmt.Printf("Returning error from scanDirectory(\"%s\") call\n", path)
		return err
	}
	for _, file := range files {
		// Соединяет путь каталога и имя файла через символ "/"
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() { // Если это подкаталог
			// рекурсивно вызывает scanDirectory,
			// но на этот раз с путем подкаталога.
			err := scanDirectory(filePath)
			if err != nil {
				// Вывод отладочной информации для ошибок в рекурсивном вызове scanDirectory
				fmt.Printf("Returning error from scanDirectory(\"%s\") call\n", path)
				return err
				// panic(err) - Можно везде возврат ошибки заменить на панику
			}
		} else {
			fmt.Println(filePath)
		}
	}
	return nil
}

func reportPanic() {
	p := recover()
	if p == nil {
		return
	}
	err, ok := p.(error)
	if ok {
		fmt.Println(err)
	} else {
		// Если значение паники не является признаком ошибки,
		// возобновить панику с тем же значением
		panic(p)
	}
}

func main() {
	err := scanDirectory("Chapter_12/my_huge_directory")
	if err != nil {
		log.Fatal(err)
	}
}

/*
Мы, как и создатели языка Go, настоятельно рекомендуем так не поступать.
Можно даже сказать, что сама архитектура языка не способствует использованию panic и recover.
В своем докладе на конференции в 2012 году Роб Пайк (один из создателей Go) описывал panic и recover как «намеренно неудобные».
Это означает, что при проектировании Go его создатели не пытались сделать panic и recover простыми или приятными в использовании, они хотели, чтобы эти функции использовались реже.

Так проектировщики языка Go отреагировали на один из главных недостатков исключений:
они существенно усложняют логику программы.
Вместо этого разработчикам рекомендуется обрабатывать ошибки точно так же,
как они обрабатываются в других частях программы:
в командах if и return наряду со значениями ошибок.
Конечно, прямая обработка ошибок внутри функции несколько удлиняет код этой функции,
но это лучше, чем полный отказ от обработки ошибок.
(Создатели Go обнаружили, что многие разработчики, использующие исключения, просто инициируют исключение, не обеспечивая его должной обработки в будущем.)
Прямая обработка ошибок также более наглядно показывает,
что происходит при возникновении ошибки — вам не нужно просматривать другую ветвь логики программы,
чтобы увидеть код обработки ошибок.

Итак, не ищите эквивалент исключений в Go. Этот механизм был опущен намеренно.
Возможно, разработчики с опытом использования исключений не сразу
привыкнут к новым средствам обработки ошибок,
но создатели Go полагают, что в итоге это приведет к созданию более качественных программных продуктов.

Тезисы доклада Роба Пайка доступны по адресу
https://talks.golang.org/2012/splash.
article#TOC_16.
*/
